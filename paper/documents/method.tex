\section{研究内容}
\label{section:研究内容}
観光案内アプリにPWAを導入することを想定して調査や分析を行う。まずはPWAと深い関わりがあるWeb APIの、PWAにおける有用性を調査する。続いてService Workerのパフォーマンスを評価する。
\subsection{PWAにおけるWeb APIの有用性の調査}\label{subsection:PWAにおけるWeb APIの有用性の調査}
Web APIはPWAをプラットフォーム固有のアプリ(ネイティブアプリ)に近づけるために不可欠な技術である。ネイティブアプリの機能の多くはSDK(Software Development Kit)により提供されている。SDKは、特定のフレームワークやプラットフォーム上にアプリケーションを構築するために使用する開発ツールのセットである。Webアプリ開発では、SDKの代わりにWeb APIを使用できる。API(Application Programming Interface)はプログラム同士が相互に通信するための方法である。SDKと同様に、開発者が複雑な機能をより簡単に作成できるようにするために提供されており、APIを使用することで複雑なコードが抽象化され、構文がより簡潔になる。Web APIはこのAPIの1つであり、HTTPなどのWebの技術を利用したものである。Web APIにはいくつかの種類があるが、この論文では特に、WebブラウザーのAPIのうち、W3Cなどにより標準化されたものを扱うことにする。以後この論文では、Webブラウザーの標準化されたAPIという意味でWeb APIという語句を使用する。
\subsubsection{Web APIのWebブラウザー側の対応状況の調査}
\label{subsubsection:Web APIのWebブラウザー側の対応状況の調査}
開発者が実際に特定のWeb APIを利用するためには、WebブラウザーがそのWeb APIに対応している必要がある。特に、シェアが大きいWebブラウザーの対応状況や、レンダリングエンジンが異なるWebブラウザー間の対応状況を把握することは、Webアプリのコンバージョンを高めたり、自由なWebを維持したりする上で重要である。主要なWebブラウザーのシェアや特徴は以下の通りである。なお、シェアはすべてのプラットフォームの2023年9月時点のデータを基に算出している~\cite{StatCounterBrowserMarketShare}。
\begin{itemize}
    \item Google Chrome
    \begin{itemize}
        \item シェア: 約63\%
        \item レンダリングエンジン
        \begin{itemize}
            \item HTML: Blink
            \item JavaScript: V8
        \end{itemize}
        \item チャンネル~\cite{GoogleChromeChannels}
        \begin{itemize}
            \item Stable
            \item Extended Stable
            \item Beta
            \item Dev
            \item Canary
        \end{itemize}
    \end{itemize}
    \item Safari
    \begin{itemize}
        \item シェア: 約20\%
        \item レンダリングエンジン
        \begin{itemize}
            \item HTML: WebKit
            \item JavaScript: Nitro
        \end{itemize}
        \item チャンネル~\cite{SafariChannels}
        \begin{itemize}
            \item Safari
            \item Beta
            \item Technology Preview
        \end{itemize}
    \end{itemize}
    \item Microsoft Edge
    \begin{itemize}
        \item シェア: 約5\%
        \item レンダリングエンジン
        \begin{itemize}
            \item HTML: Blink
            \item JavaScript: V8
        \end{itemize}
        \item チャンネル~\cite{MicrosoftEdgeChannels}
        \begin{itemize}
            \item Stable
            \item Extended Stable
            \item Beta
            \item Dev
            \item Canary
        \end{itemize}
    \end{itemize}
    \item Mozilla Firefox
    \begin{itemize}
        \item シェア: 約3\%
        \item レンダリングエンジン
        \begin{itemize}
            \item HTML: Gecko
            \item JavaScript: SpiderMonkey
        \end{itemize}
        \item チャンネル~\cite{MozillaFirefoxChannels}
        \begin{itemize}
            \item Firefox
            \item Extended Support Release(ESR)
            \item Beta
            \item Developer Edition
            \item Nightly
        \end{itemize}
    \end{itemize}
\end{itemize}
次に、前述した情報を踏まえ、Webブラウザー間におけるWeb APIの対応状況の違いを考える上で、着目するべき点を挙げる。まずは、Google Chromeのシェアとその他のWebブラウザーのシェアの間に大きな差があることを確認できる。次に、Google ChromeとMicrosoft Edgeの特徴が似ていることを確認できる。Microsoft EdgeはGoogle Chromeと同様にChromiumというWebブラウザーから派生しているためである。Web APIの対応状況についてもほとんど同じである。そこで、Google ChromeとMicrosoft Edgeは同一のWebブラウザーであるとみなし、よりシェアが大きいGoogle Chromeを調査対象とする。

続いて、HTMLのレンダリングエンジンの違いに注目する。まず、SafariはBlinkのフォーク元であるWebKitを利用している。そのため、SafariにはGoogle ChromeやMicrosoft Edgeと共通のコードベースが含まれる可能性がある。さらに、WebKitは独自のエコシステムを持っている。例えば、iOS上のWebブラウザーはWebKit以外のHTMLレンダリングエンジンを使用できない。これにより、iOS上のWebブラウザー間の機能の違いが少なくなり、iOSにデフォルトでインストールされているSafariの市場優位性が高まる。Mozilla Firefoxについては、シェアは少ないものの、WebKitから完全に独立したHTMLレンダリングエンジンであるGeckoを採用している。また、プライバシーを重視する傾向にあり、PWAに関連するWeb APIの策定に積極的であるGoogle Chromeとは対照的である。そのため、Google Chromeに加えてMozilla Firefoxも調査対象とする。

次に、Web APIのWebブラウザー側の対応状況を調べる際に参照する文献の候補を示す。Can I use…~\cite{CanIUse}は様々なWebブラウザーがサポートする機能を検索できるWebサイトである。CC BY 4.0ライセンスを採用し、コミュニティーがWebサイトの情報を更新している。これに加えて、より信ぴょう性が高い情報を得るために、それぞれのWebブラウザーベンダーが提供しているRelease notesを参照する。これは、新しいバージョンのソフトウェアをリリースする際に公表される、以前のバージョンからの変更点を示す文書である。また、より詳細な情報を入手するために、必要に応じてWebブラウザーベンダーのブログ記事を参照する。
\subsubsection{Web APIに対する意見や主張の調査}
\label{subsubsection:Web APIに対する意見や主張の調査}
それぞれのWeb APIに対する意見や主張は、Web APIの有用性を測るための1つの指標となり得る。Web APIに対する意見や主張を表明するための文書としてはStandards Positionsがある。これは、Web標準の技術に対する開発コミュニティーの立場をまとめたものである。主な立場としては賛成(support、positive)、中立(neutral)、反対(oppose、negative)がある。GitHubなどのプラットフォーム上で、特定のWeb標準の技術に対する賛否の議論が行われ、その後に開発コミュニティーの代表者が立場を表明する。まずは、Standards Positionsでの立場やその根拠となる議論を調査し、Web APIの現在の有用性を評価する。さらに、Web APIに対する議論の方向性を基にWeb APIの将来の見通しを考察する。

メディアを制御するWeb APIのWebブラウザーの対応状況を表~\ref{table:メディアを制御するWeb APIの対応状況}に示す。そのWeb APIに対するベンダーの意見を表~\ref{table:メディアを制御するWeb APIに対する意見}に示す。
\begin{table}
  \caption{メディアを制御するWeb APIの対応状況}
  \label{table:メディアを制御するWeb APIの対応状況}
  \centering
  \begin{tabular}{|p{13em}|p{8em}|p{8em}|}
    \hline
    & Google Chrome & Mozilla Firefox \\ \hline
    Media Capture and Streams API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
    MediaStream Recording API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
    Media Session API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
    Media Stream Image Capture API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
    Media Capabilities API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
  \end{tabular}
\end{table}
\begin{table}
  \caption{メディアを制御するWeb APIに対する意見}
  \label{table:メディアを制御するWeb APIに対する意見}
    \centering
    \begin{tabular}{|p{13em}|p{13em}|p{13em}|}
        \hline
        & Mozilla & WebKit \\ \hline
        Media Capture and Streams API & 不明 & \cellcolor{green!25}OSの違いに柔軟に対処できる方法でOSがサポートする機能を公開できる\cite{WebKitMediaCaptureandStreamsAPI} \\ \hline
        MediaStream Recording API & 不明 & 不明 \\ \hline
        Media Session API & \cellcolor{green!25}モバイル端末で特に有用である~\cite{MozillaMediaSessionAPI} & 不明 \\ \hline
        Media Stream Image Capture API & 不明 & 不明 \\ \hline
        Media Capabilities API & \cellcolor{green!25}主要なWebサイトで実際に使用されている\cite{MozillaMediaCapabilitiesAPI} & 不明 \\ \hline
    \end{tabular}
\end{table}
Media Capture and Streams APIはカメラによるストリーミングを提供する。MediaStream Recording APIと組み合わせることで、音声や動画のストリーミングを収録できる。これらのAPIを活用すると、画面共有やビデオ通話といった機能を簡単に実装できる。Media Stream Image Capture APIと組み合わせることで写真を撮影することもできる。getUserMedia()によってカメラやマイクへの明示的なアクセス許可を求められるため、ユーザーが処理の流れを理解しやすい点や、再生ボタンをクリックするなどのアクションに関連付けられている点で挙動が明確である。

モジュールにアクセスするWeb APIのWebブラウザーの対応状況を表~\ref{table:モジュールにアクセスするWeb APIの対応状況}に示す。そのWeb APIに対するベンダーの意見を表~\ref{table:モジュールにアクセスするWeb APIに対する意見}に示す。
\begin{table}
  \caption{モジュールにアクセスするWeb APIの対応状況}
  \label{table:モジュールにアクセスするWeb APIの対応状況}
  \centering
  \begin{tabular}{|p{13em}|p{8em}|p{8em}|}
    \hline
    & Google Chrome & Mozilla Firefox \\ \hline
    Geolocaion API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
    Web Bluetooth API & \cellcolor{green!25}対応 & \cellcolor{red!25}非対応 \\ \hline
    Web NFC API & \cellcolor{red!25}非対応 & \cellcolor{red!25}非対応 \\ \hline
    Vibration API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
  \end{tabular}
\end{table}
\begin{table}
    \centering
    \caption{モジュールにアクセスするWeb APIに対する意見}
    \label{table:モジュールにアクセスするWeb APIに対する意見}
    \begin{tabular}{|p{13em}|p{13em}|p{13em}|}
         \hline
         & Mozilla & WebKit \\ \hline
         Geolocaion API & 不明 & 不明 \\ \hline
         Web Bluetooth API & \cellcolor{red!25}セマンティックではないインターフェイスがWebプラットフォームに公開される~\cite{MozillaWebBluetoothAPI} & 不明 \\ \hline
         Web NFC API & \cellcolor{red!25}物理的な認証デバイスのデータをWebサイトが取得する可能性がある~\cite{MozillaWebNFCAPI} & 不明 \\ \hline
         Vibration API & 不明 & \cellcolor{red!25}通知の仕組みが悪用される可能性がある \\ \hline
    \end{tabular}
\end{table}
Geolocation APIはユーザーの位置情報を取得する。ユーザーの位置を地図上にプロットしたり、ユーザーの位置情報を用いて、パーソナライズされた情報を表示したい場合に便利である。プライバシー上の理由から明示的なアクセス許可やHTTPS通信が必要である。
Web Bluetooth APIはBluetooth Low Energyの周辺機器に接続して操作する機能を提供する。しかし、WebアプリがBluetooth端末に接続する場合は、そのアプリがどのような意図でその端末に接続しようとしているのかが明確に定義できないため、潜在的な危険性が高いと指摘されている。

バックグラウンド処理を行うWeb APIのWebブラウザーの対応状況を表~\ref{table:バックグラウンド処理を行うWeb APIの対応状況}に示す。そのWeb APIに対するベンダーの意見を表~\ref{table:バックグラウンド処理を行うWeb APIに対する意見}に示す。
\begin{table}
  \caption{バックグラウンド処理を行うWeb APIの対応状況}\label{table:バックグラウンド処理を行うWeb APIの対応状況}
  \centering
  \begin{tabular}{|p{13em}|p{8em}|p{8em}|}
    \hline
    & Google Chrome & Mozilla Firefox \\ \hline
    Background Tasks API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
    Background Fetch API & \cellcolor{green!25}対応 & \cellcolor{red!25}非対応 \\ \hline
    Background Synchronization API & \cellcolor{green!25}対応 & \cellcolor{red!25}非対応 \\ \hline
  \end{tabular}
\end{table}
\begin{table}
  \caption{バックグラウンド処理を行うWeb APIに対する意見}
  \label{table:バックグラウンド処理を行うWeb APIに対する意見}
    \centering
    \begin{tabular}{|p{13em}|p{13em}|p{13em}|}
        \hline
        & Mozilla & WebKit \\ \hline
        Background Tasks API & 不明 & 不明 \\ \hline
        Background Fetch API & \cellcolor{red!25}バックグラウンドでスクリプトが実行される~\cite{MozillaBackgroundFetchAPI} & \cellcolor{red!25}ユーザーがWebサイトにアクセスしていないときにWebサイトのアクティビティーが実行される~\cite{WebKitBackgroundFetchAPI} \\ \hline
        Background Synchronization API & \cellcolor{red!25}バッテリーが消耗しやすい、最初にアクセスしたネットワークと異なるネットワークでアクティビティーが発生する~\cite{MozillaBackgroundSynchronizationAPI} & \cellcolor{red!25}電力とセキュリティーの懸念がある \\ \hline
    \end{tabular}
\end{table}
Background Tasks APIはタスクをキューに入れて優先度が高いものから順番に実行する。キューに入れられたタスクはバックグラウンドで実行されるため、Web Workerを使用せずにシステムの遅延を削減できる長所がある。Background Fetch APIは大容量のファイルをバックグラウンドでフェッチする。オフラインでフェッチリクエストが実行された場合は、ユーザーが再びオンラインになるまでプロセスを一時停止させることもできる。Background Fetch APIが実行する処理は実質的にはバックグラウンドでのダウンロードやアップロードであり、それらの処理の後にスクリプトがバックグラウンドで実行される可能性がある。ユーザーの明示的な操作を必須にすることや、Background Fetch APIがSame-Originのコンテンツのみを扱えるように制限するべきであるという声もある。Background Synchronization APIは安定したネットワーク接続が確立されるまでタスクを延期する。このAPIを使用して延期されたタスクは、異なるネットワーク上で実行される可能性があるため、ユーザーが意図しない処理が行われることが懸念されている。

ファイルにアクセスするWeb APIのWebブラウザーの対応状況を表~\ref{table:ファイルにアクセスするWeb APIの対応状況}に示す。そのWeb APIに対するベンダーの意見を表~\ref{table:ファイルにアクセスするWeb APIに対する意見}に示す。
\begin{table}
  \caption{ファイルにアクセスするWeb APIの対応状況}\label{table:ファイルにアクセスするWeb APIの対応状況}
  \centering
  \begin{tabular}{|p{13em}|p{8em}|p{8em}|}
    \hline
    & Google Chrome & Mozilla Firefox \\ \hline
    File API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
    File System Access API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
    File System API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
  \end{tabular}
\end{table}
\begin{table}
  \caption{ファイルにアクセスするWeb APIに対する意見}
  \label{table:ファイルにアクセスするWeb APIに対する意見}
    \centering
    \begin{tabular}{|p{13em}|p{13em}|p{13em}|}
        \hline
        & Mozilla & WebKit \\ \hline
        File API & 不明 & 不明 \\ \hline
        File System Access API & \cellcolor{red!25}APIのリスクをユーザーに適切に伝える方法が不明確である\cite{MozillaFileSystemAccessAPI} & \cellcolor{red!25}ユーザーの利益を保護しながらローカルファイルシステムへの書き込みアクセスを許可する方法が不明確である~\cite{WebKitFileSystemAccessAPI} \\ \hline
        File System API & 不明 & 不明\\ \hline
    \end{tabular}
\end{table}
File APIは端末のファイルとそのコンテンツにアクセスする。File APIよりも汎用性が高いAPIとしてはFile System Access APIがある。File System Access APIは端末のファイルシステム上のファイルにアクセスしてファイルを読み込んだり、ファイルに書き込んだりできる。File System APIはWebブラウザーに仮想ドライブを作成し、そのストレージにファイルを保存するものであり、File System APIとFile System Access APIはそれぞれ異なるAPIである。File System Access APIは端末のすべてのディレクトリとファイルにアクセスする権限を持つため、悪用されるリスクがある。許可を求めるプロンプトの表示などによって、このAPIが行おうとしている操作をユーザーに分かりやすく提示することで安全性を確保できるという意見もある。

通知を制御するWeb APIのWebブラウザーの対応状況を表~\ref{table:通知を制御するWeb API}に示す。そのWeb APIに対するベンダーの意見を表~\ref{table:通知を制御するWeb APIに対する意見}に示す。
\begin{table}
  \caption{通知を制御するWeb API}
  \label{table:通知を制御するWeb API}
  \centering
  \begin{tabular}{|p{13em}|p{8em}|p{8em}|}
    \hline
    & Google Chrome & Mozilla Firefox \\ \hline
    Push API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
    Notifications API & \cellcolor{green!25}対応 & \cellcolor{green!25}対応 \\ \hline
    Badging API & \cellcolor{green!25}対応 & \cellcolor{red!25}非対応 \\ \hline
  \end{tabular}
\end{table}
\begin{table}
  \caption{通知を制御するWeb APIに対する意見}
  \label{table:通知を制御するWeb APIに対する意見}
    \centering
    \begin{tabular}{|p{13em}|p{13em}|p{13em}|}
        \hline
        & Mozilla & WebKit \\ \hline
        Push API & 不明 & 不明 \\ \hline
        Notifications API & 不明 & 不明 \\ \hline
        Badging API & \cellcolor{green!25}書き込み専用であるためプライバシーの観点で優れている~\cite{MozillaBadgingAPI} & 不明 \\ \hline
    \end{tabular}
\end{table}
Push APIはWebアプリがサーバーからプッシュ通知を受信する機能を提供する。Webアプリがフォアグラウンドで動作していなくても利用できるため、任意のイベントを通知してユーザーの関心を集められる。WebアプリからOSなどのシステムに対して通知を送るためにはNotifications APIを用いる。Badging APIを併用することで通知の数などの状態が変化したことをユーザーに通知できる。Notifications APIとBadging APIは、HTTPSでサーバーと通信しており、かつService WorkerなどのWebワーカーが動作しているWebアプリでのみ利用できる。
\subsection{Service Workerのパフォーマンスの評価}
\label{subsection:Service Workerのパフォーマンスの評価}
観光案内アプリでのService Workerのパフォーマンスを評価するためには、観光案内アプリに求められる機能を調査し、検証用のアプリを作成し、Service Workerのキャッシュパターンを考え、パフォーマンスを計測することが必要である。
\subsubsection{観光案内アプリに求められる機能の調査}
\label{subsubsection:観光案内アプリに求められる機能の調査}
人々が観光案内アプリと聞いて思い浮かべるものは様々である。そこで、観光案内アプリに求められる機能を調査する。初めにGoogle検索エンジンを使用して都道府県名、「観光」、「アプリ」というキーワードで検索する。次に、最上位の検索結果から順に閲覧していき、観光案内アプリを見つける。そのアプリが配信中であれば、PCやスマートフォンで実際にそのアプリを使用してアプリに実装されている機能を調査する。

初めに、検証用のアプリを作成するために現在配信されている観光案内アプリのうち、モバイルネイティブアプリで実装されている機能を調査した。それぞれの機能とその機能が実装されている割合を降順で表~\ref{table:観光案内アプリに実装されている機能}に示す。パーセンテージは小数第1位を四捨五入している。
\begin{table}
  \caption{観光案内アプリに実装されている機能}
  \label{table:観光案内アプリに実装されている機能}
  \centering
  \begin{tabular}{|p{15em}|p{10em}|}
    \hline
    & 割合[\%] \\ \hline
    観光地図 & 74 \\ \hline
    スタンプラリー & 41\\ \hline
    観光ルート案内 & 33\\ \hline
    観光名所のブックマーク & 26\\ \hline
    Wi-Fiアクセスポイントの検索 & 11 \\ \hline
  \end{tabular}
\end{table}

次に、同様のアプリで使用されているアクセス権限を調査した。それぞれのアクセス権限とそのアクセス権限が使用されている割合を降順で表~\ref{table:観光案内アプリが使用するアクセス権限}に示す。パーセンテージは小数第1位を四捨五入している。

\begin{table}
  \caption{観光案内アプリが使用するアクセス権限とその用途}
  \label{table:観光案内アプリが使用するアクセス権限とその用途}
  \centering
  \begin{tabular}{|p{10em}|p{5em}|p{15em}|}
    \hline
    & 割合[\%] & 用途 \\ \hline
    位置情報 & 93 & ユーザーの近くにある観光名所の表示、観光名所のルート案内、観光名所に近づいたときのプッシュ通知の送信 \\ \hline
    プッシュ通知 & 67 & アプリの機能の紹介、観光名所の紹介 \\ \hline
    カメラ & 26 & QRコードの読み取り、観光名所の撮影 \\ \hline
  \end{tabular}
\end{table}
観光地図は、地図レイヤーの上に観光名所などの地点をプロットして表示したものである。プロットされた地点にカーソルを合わせたり、その地点をクリックしたりすると、その地点を説明する画像やテキストが表示される。スタンプラリーは、観光名所などを訪ね、その場所に設置されているビーコンと通信したり、QRコードを読み取ったりすることでスタンプを獲得できる機能である。観光地に設置されているWi-Fiスポットに接続したいユーザー向けに、Wi-Fiアクセスポイントの検索機能を提供しているものもある。

中でも、観光地図を利用する際は観光名所や地図レイヤーの画像が配信されるため、データの通信量が大きくなる。このような場合はService Workerによるキャッシュの恩恵を受けられる。また、実装されている割合が最も大きいため、この機能は多くの観光案内アプリが持つ特徴の1つであると考えられる。観光地図を実装したWebアプリを作成してそのパフォーマンスを計測することで、観光案内アプリにおけるService Workerのパフォーマンスを評価する。
\subsubsection{検証用のアプリの作成}
\label{subsubsection:検証用のアプリの作成}
一般的にWebアプリはフレームワークを使用して作成される。そのため、検証用のアプリを作成する際も同種のソフトウェアを使用する。HTMLの生成方法は大きく分けて2種類あり、どちらを採用するかを決める必要がある。まずは、それらの方法を説明する。

最も基本的なHTMLの生成方法としては動的な生成がある。ユーザーがページにアクセスするたびにサーバー側でHTMLファイルが生成される。動的な生成を使用すると、ユーザーから任意のパラメーターを受け取り、それに基づいてHTMLを生成できる。後述する静的な生成では、Webアプリのプログラムを変更するたびにHTMLを生成し直さなければならないが、動的な生成ではその必要がないため、最新の情報を素早くユーザーに届けられる。動的な生成はSSR(Server Side Rendering)という仕組みによって実現しており、通常、HTMLを動的に生成する場合は、WebサーバーとWebアプリサーバーが必要である。

もう1つの生成方法は静的な生成である。Webアプリを変更してデプロイする際にはビルドという処理が行われるが、静的な生成では、この処理を行う際にそれぞれのページのHTMLファイルが生成される。したがって、ユーザーが特定のページにアクセスした際にクライアントに返却されるHTMLの内容は、ビルドが更新されない限り常に同じである。静的な生成はSSG(Static Site Generator)という仕組みによって実現しており、HTMLを静的に生成する場合はWebサーバーが必要である。

前述したように、静的な生成ではWebアプリのプログラムを変更するたびにHTMLを生成し直さなければならないという短所があり、コンテンツ指向型のWebアプリで静的なHTML生成が用いられることは少ない。そこで、検証用のアプリの作成時はHTMLを動的に生成する方法であるSSRを使用する。

次に観光地図を検証用のアプリに実装する。まずはOpenStreetMap~\cite{OpenStreetMap}を使用して地図レイヤーを表示する。OpenStreetMap(OSM)はコミュニティーによってメンテナンスされている、オープンソースの世界地図および地理データベースである。Overpass APIを使用して、観光名所に分類されるOSMのノードをJSONデータとして取得する。このノードをOSMの世界地図にプロットすることで、観光名所の場所がプロットされた地図を作成できる。Google Mapsに代表されるように、アプリに地図を表示する場合は、ズーム倍率を変更したり、自由にスクロールしたりできるインタラクティブ性が必要である。これを満たすためにLeaflet~\cite{Leaflet}を使用する。観光名所のマーカーにカーソルを合わせたり、そのマーカーをクリックした際に表示される画像やテキストを取得するために、JSONPlaceholderを使用する。JSONPlaceholderは、画像やテキストのダミーデータをREST APIで提供する。通常の観光地図には、特定の地域の観光名所のみがプロットされている。そのため、検証用のアプリでは国内の観光名所を都道府県ごとに表示する。
\subsubsection{Service Workerのキャッシュ戦略}
\label{Service Workerのキャッシュパターン}
Service Workerのキャッシュパターンはキャッシュ戦略と呼ばれ、Service Workerを効果的に使用するために必要である。どのコンテンツをキャッシュするべきかはアプリの内容によって異なるため、キャッシュ戦略は無数にあるが、参考までにいくつか例を示す。

まずは、Service Workerのインストール時に全てのアセットをキャッシュする戦略がある。この戦略ではService Workerはアセットのキャッシュのみを返すため、HTMLなどのネットワークリクエストはService Workerを経由せず、キャッシュされない。

あるいは、全てのネットワークリクエストをService Workerに経由させる戦略もある。この戦略ではコンテンツは一切キャッシュされないが、常に最新のネットワークレスポンスを受け取れる。しかし、ユーザーがオフラインのときはWebアプリが機能しない。

このように、Service Workerはネットワークリクエストを仲介する役割を持つ。そのため、Service Workerを用いて一部のコンテンツのみをキャッシュすることもできる。キャッシュ対象のコンテンツの種類や範囲を変化させることでSerivce Workerのパフォーマンス評価を行うことにし、3種類のキャッシュ戦略を策定した。

1つ目はすべてのネットワークレスポンスをキャッシュする戦略である。この戦略では、HTML、CSS、JavaScript、画像、JSONなどのあらゆるネットワークレスポンスがService Workerによって全てキャッシュされる。同じページがもう1度読み込まれると、全てのネットワークレスポンスがキャッシュを利用するため、実質的にネットワークリクエストが発生しない。

2つ目はSame-Originのネットワークレスポンスをキャッシュする戦略である。この戦略ではWebアプリがデプロイされているドメイン(Same-Origin)に対するネットワークリクエストのみがキャッシュされる。同じページがもう1度読み込まれると、Same-OriginのネットワークレスポンスはCache Storageにあるキャッシュを利用し、Cross-Originのネットワークレスポンスはそのキャッシュを利用しない。

3つ目は画像をキャッシュする戦略である。観光案内アプリでは多くの画像が配信されるため、画像を積極的にキャッシュした際のパフォーマンスを知ることは、観光案内アプリでのPWAの有用性を評価する上で重要である。
\subsubsection{Service Workerのパフォーマンスの計測}
\label{subsubsection:Service Workerのパフォーマンスの計測}
現在広く普及しているWebアプリの品質測定ツールとしてLighthouseがある。Lighthouseを使用すると、任意のページに対してパフォーマンス、ユーザー補助、PWA、SEOなどの監査を実施できる。今回はパフォーマンスに着目しているため、パフォーマンスの監査のみを実施する。より正確な指標を得るために、LighthouseのNodeモジュールを使用してモバイル端末での読み込みをエミュレートする。

Lighthouseのパフォーマンスの値は0から1で表され、監査項目の条件を満たしているほど、すなわちページの品質が高いほどその値が大きくなる。パフォーマンスの評価に役立つその他の指標としては以下のようなメトリクスがある。

\begin{itemize}
    \item First Contentful Paint(FCP)
    \begin{itemize}
        \item ページのナビゲーションが開始されてから、Webブラウザーがコンテンツの最初の部分をレンダリングするまでにかかる時間である。このコンテンツとはテキスト、画像、<svg>要素、白以外の<canvas>要素を指す。
    \end{itemize}
    \item Largest Contentful Paint(LCP)
    \begin{itemize}
        \item ページのナビゲーションが開始されてから、最も大きな画像またはテキストブロックをレンダリングするまでにかかる時間である。
    \end{itemize}
    \item Speed Index(SI)
    \begin{itemize}
        \item ページの読み込み中にコンテンツが視覚的に表示される速度である。ページを読み込む際に発生するフレーム間の視覚的な変化を計算し、SpeedlineというNodeモジュールを使用して点数を生成する。
    \end{itemize}
    \item Total Blocking Time(TBT)
    \begin{itemize}
        \item マクスのクリック、画面のタップ、キーボードの押下などのユーザー入力に対するページの応答がブロックされている合計時間である。
    \end{itemize}
    \item Cumulative Layput Shift(CLS)
    \begin{itemize}
        \item ページの読み込みの開始から終了までの間に発生したセッションウィンドウのうち、そのウィンドウ内のレイアウトシフトの累積値が最も大きいセッションウィンドウの測定値である。
    \end{itemize}
\end{itemize}

モバイル端末をエミュレートする際は、端末の幅、高さ、性能に加えてモバイル端末の通信環境もエミュレートする必要がある。4G以前のモバイル通信システムはIEEE 802.11acなどの広く普及している無線LANの標準規格に比べて通信速度が低いため、無線LANに接続した端末で、ネットワークエミュレーションを行わずにパフォーマンスを計測すると、実際のモバイル端末でのパフォーマンスを正確に計測できない可能性が高い。この問題を回避するためにネットワークスロットリングを使用する。ネットワークスロットリングとはインターネットの速度を意図的に低下させ、低帯域の状態をエミュレートすることである。ネットワークスロットリングには以下の4種類がある。

\begin{itemize}
    \item シミュレートされたスロットリング
    \begin{itemize}
        \item スロットリングされていない最初の読み込みで観察されたデータに基づいてページの読み込みをシミュレートする。高速であるが一部のサイトではスロットリングの正確性が低い。
    \end{itemize}
    \item リクエストレベルのスロットリング
    \begin{itemize}
        \item ネットワークリクエストごとにスロットリングを行う。スロットリングの正確性はSimulated throttlingと同じ程度である。
    \end{itemize}
    \item プロキシーレベルのスロットリング
    \begin{itemize}
        \item HTTPサーバーを経由したTCPやUDPのネットワークリクエストごとにスロットリングを行う。
    \end{itemize}
    \item パケットレベルのスロットリング
    \begin{itemize}
        \item パケットごとにスロットリングを行う。このスロットリングを使用することで最も正確なネットワークシミュレーションを行える。
    \end{itemize}
\end{itemize}

この研究では、より正確なデータを得るために、パケットレベルのスロットリングを使用してパフォーマンスを計測する。パケットレベルのスロットリングを行うためにThrottle~\cite{Throttle}というライブラリを使用する。パフォーマンスを計測する際に使用するネットワークスロットリングのプロファイルを表~\ref{table:ネットワークスロットリングのプロファイル}に示す。
\begin{table}
  \caption{ネットワークスロットリングのプロファイル}
  \label{table:ネットワークスロットリングのプロファイル}
  \centering
  \begin{tabular}{|p{5em}|p{10em}|p{10em}|p{10em}|}
    \hline
    & アップリンク[Kbit/s] & ダウンリンク[Kbit/s] & RTT[ms] \\ \hline
    3gslow & 400 & 400 & 200 \\ \hline
    3gfast & 768 & 1600 & 75 \\ \hline
    4g & 9000 & 9000 & 85 \\ \hline
  \end{tabular}
\end{table}
パフォーマンスの計測からデータの分析までの流れは以下の通りである。
\begin{enumerate}
    \item 予め定義されているスロットリングのプロファイルを用いてネットワークスロットリングを有効にする
    \item Lighthouseを用いてパフォーマンスを計測するプログラムを実行する
    \item csv形式のファイルにLighthouseが収集したデータが記録される
    \item データ分析ツールを用いてそのファイルに記録されたデータを分析する
\end{enumerate}