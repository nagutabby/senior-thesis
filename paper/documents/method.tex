\section{研究内容}\label{section:研究内容}
観光案内アプリにPWAを導入することを想定して調査や分析を行う。まずはPWAと深い関わりがあるWeb APIの、PWAにおける有用性を調査する。続いてService Workerのパフォーマンスを評価する。
\subsection{PWAにおけるWeb APIの有用性の調査}\label{subsection:PWAにおけるWeb APIの有用性の調査}
Web APIはPWAをプラットフォーム固有のアプリ(ネイティブアプリ)に近づけるために不可欠な技術である。ネイティブアプリの機能の多くはSDK(Software Development Kit)により提供されている。SDKは、特定のフレームワークやプラットフォーム上にアプリケーションを構築するために使用する開発ツールのセットである。Webアプリ開発では、SDKの代わりにWeb APIを使用できる。API(Application Programming Interface)はプログラム同士が相互に通信するための方法である。SDKと同様に、開発者が複雑な機能をより簡単に作成できるようにするために提供されており、APIを使用することで複雑なコードが抽象化され、構文がより簡潔になる。Web APIはこのAPIの1つであり、HTTPなどのWebの技術を利用したものである。Web APIにはいくつかの種類があるが、この論文では特に、WebブラウザーのAPIのうち、W3Cなどにより標準化されたものを扱うことにする。以後この論文では、Webブラウザーの標準化されたAPIという意味でWeb APIという語句を使用する。
\subsubsection{Web APIのWebブラウザー側の対応状況の調査}\label{subsubsection:Web APIのWebブラウザー側の対応状況の調査}
開発者が実際に特定のWeb APIを利用するためには、WebブラウザーがそのWeb APIに対応している必要がある。特に、シェアが大きいWebブラウザーの対応状況や、レンダリングエンジンが異なるWebブラウザー間の対応状況を把握することは、Webアプリのコンバージョンを高めたり、自由なWebを維持したりする上で重要である。主要なWebブラウザーのシェアや特徴は以下の通りである。なお、シェアはすべてのプラットフォームの2023年9月時点のデータを基に算出している~\cite{StatCounterBrowserMarketShare}。
\begin{itemize}
    \item Google Chrome
    \begin{itemize}
        \item シェア: 約63\%
        \item レンダリングエンジン
        \begin{itemize}
            \item HTML: Blink
            \item JavaScript: V8
        \end{itemize}
        \item チャンネル~\cite{GoogleChromeChannels}
        \begin{itemize}
            \item Stable
            \item Extended Stable
            \item Beta
            \item Dev
            \item Canary
        \end{itemize}
    \end{itemize}
    \item Safari
    \begin{itemize}
        \item シェア: 約20\%
        \item レンダリングエンジン
        \begin{itemize}
            \item HTML: WebKit
            \item JavaScript: Nitro
        \end{itemize}
        \item チャンネル~\cite{SafariChannels}
        \begin{itemize}
            \item Safari
            \item Beta
            \item Technology Preview
        \end{itemize}
    \end{itemize}
    \item Microsoft Edge
    \begin{itemize}
        \item シェア: 約5\%
        \item レンダリングエンジン
        \begin{itemize}
            \item HTML: Blink
            \item JavaScript: V8
        \end{itemize}
        \item チャンネル~\cite{MicrosoftEdgeChannels}
        \begin{itemize}
            \item Stable
            \item Extended Stable
            \item Beta
            \item Dev
            \item Canary
        \end{itemize}
    \end{itemize}
    \item Mozilla Firefox
    \begin{itemize}
        \item シェア: 約3\%
        \item レンダリングエンジン
        \begin{itemize}
            \item HTML: Gecko
            \item JavaScript: SpiderMonkey
        \end{itemize}
        \item チャンネル~\cite{MozillaFirefoxChannels}
        \begin{itemize}
            \item Firefox
            \item Extended Support Release(ESR)
            \item Beta
            \item Developer Edition
            \item Nightly
        \end{itemize}
    \end{itemize}
\end{itemize}
次に、前述した情報を踏まえ、Webブラウザー間におけるWeb APIの対応状況の違いを考える上で、着目するべき点を挙げる。まずは、Google Chromeのシェアとその他のWebブラウザーのシェアの間に大きな差があることを確認できる。次に、Google ChromeとMicrosoft Edgeの特徴が似ていることを確認できる。Microsoft EdgeはGoogle Chromeと同様にChromiumというWebブラウザーから派生しているためである。Web APIの対応状況についてもほとんど同じである。そこで、Google ChromeとMicrosoft Edgeは同一のWebブラウザーであるとみなし、よりシェアが大きいGoogle Chromeを調査対象とする。

続いて、HTMLのレンダリングエンジンの違いに注目する。まず、SafariはBlinkのフォーク元であるWebKitを利用している。そのため、SafariにはGoogle ChromeやMicrosoft Edgeと共通のコードベースが含まれる可能性がある。さらに、WebKitは独自のエコシステムを持っている。例えば、iOS上のWebブラウザーはWebKit以外のHTMLレンダリングエンジンを使用できない。これにより、iOS上のWebブラウザー間の機能の違いが少なくなり、iOSにデフォルトでインストールされているSafariの市場優位性が高まる。Mozilla Firefoxについては、シェアは少ないものの、WebKitから完全に独立したHTMLレンダリングエンジンであるGeckoを採用している。また、プライバシーを重視する傾向にあり、PWAに関連するWeb APIの策定に積極的であるGoogle Chromeとは対照的である。そのため、Google Chromeに加えてMozilla Firefoxも調査対象とする。

次に、Web APIのWebブラウザー側の対応状況を調べる際に参照する文献の候補を示す。Can I use…~\cite{CanIUse}は様々なWebブラウザーがサポートする機能を検索できるWebサイトである。CC BY 4.0ライセンスを採用し、コミュニティーがWebサイトの情報を更新している。これに加えて、より信ぴょう性が高い情報を得るために、それぞれのWebブラウザーベンダーが提供しているRelease notesを参照する。これは、新しいバージョンのソフトウェアをリリースする際に公表される、以前のバージョンからの変更点を示す文書である。また、より詳細な情報を入手するために、必要に応じてWebブラウザーベンダーのブログ記事を参照する。
\subsubsection{Web APIに対する意見や主張の調査}\label{subsubsection:Web APIに対する意見や主張の調査}
それぞれのWeb APIに対する意見や主張は、Web APIの有用性を測るための1つの指標となり得る。Web APIに対する意見や主張を表明するための文書としてはStandards Positionsがある。これは、Web標準の技術に対する開発コミュニティーの立場をまとめたものである。主な立場としては賛成(support、positive)、中立(neutral)、反対(oppose、negative)がある。GitHubなどのプラットフォーム上で、特定のWeb標準の技術に対する賛否の議論が行われ、その後に開発コミュニティーの代表者が立場を表明する。まずは、Standards Positionsでの立場やその根拠となる議論を調査し、Web APIの現在の有用性を評価する。さらに、Web APIに対する議論の方向性を基にWeb APIの将来の見通しを考察する。
\subsection{Service Workerのパフォーマンスの評価}\label{subsection:Service Workerのパフォーマンスの評価}
観光案内アプリでのService Workerのパフォーマンスを評価するためには、観光案内アプリに求められる機能を調査し、検証用のアプリを作成し、Service Workerのキャッシュパターンを考え、パフォーマンスを計測することが必要である。
\subsubsection{観光案内アプリに求められる機能の調査}\label{subsubsection:観光案内アプリに求められる機能の調査}
人々が観光案内アプリと聞いて思い浮かべるものは様々である。そこで、観光案内アプリに求められる機能を調査する。初めにGoogle検索エンジンを使用して都道府県名、「観光」、「アプリ」というキーワードで検索する。次に、最上位の検索結果から順に閲覧していき、観光案内アプリを見つける。そのアプリが配信中であれば、PCやスマートフォンで実際にそのアプリを使用してアプリに実装されている機能を調査する。

初めに、検証用のアプリを作成するために現在配信されている観光案内アプリのうち、モバイルネイティブアプリで実装されている機能を調査した。それぞれの機能とその機能が実装されている割合を降順で表~\ref{table:観光案内アプリに実装されている機能}に示す。パーセンテージは小数第1位を四捨五入している。
\begin{table}
  \caption{観光案内アプリに実装されている機能}\label{table:観光案内アプリに実装されている機能}
  \centering
  \begin{tabular}{|p{15em}|p{10em}|}
    \hline
    & 割合[\%] \\ \hline
    観光地図 & 74 \\ \hline
    スタンプラリー & 41\\ \hline
    観光ルート案内 & 33\\ \hline
    観光名所のブックマーク & 26\\ \hline
    Wi-Fiアクセスポイントの検索 & 11 \\ \hline
  \end{tabular}
\end{table}

次に、同様のアプリで使用されているアクセス権限を調査した。それぞれのアクセス権限とそのアクセス権限が使用されている割合を降順で表~\ref{table:観光案内アプリが使用するアクセス権限}に示す。パーセンテージは小数第1位を四捨五入している。

\begin{table}
  \caption{観光案内アプリが使用するアクセス権限}\label{table:観光案内アプリが使用するアクセス権限}
  \centering
  \begin{tabular}{|p{15em}|p{10em}|}
    \hline
    & 割合[\%] \\ \hline
    位置情報 & 93 \\ \hline
    プッシュ通知 & 67 \\ \hline
    カメラ & 26 \\ \hline
  \end{tabular}
\end{table}

観光地図は、地図レイヤーの上に観光名所などの地点をプロットして表示したものである。プロットされた地点にカーソルを合わせたり、その地点をクリックしたりすると、その地点を説明する画像やテキストが表示される。スタンプラリーは、観光名所などを訪ね、その場所に設置されているビーコンと通信したり、QRコードを読み取ったりすることでスタンプを獲得できる機能である。観光地に設置されているWi-Fiスポットに接続したいユーザー向けに、Wi-Fiアクセスポイントの検索機能を提供しているものもある。

中でも、観光地図を利用する際は観光名所や地図レイヤーの画像が配信されるため、データの通信量が大きくなる。このような場合はService Workerによるキャッシュの恩恵を受けられる。また、実装されている割合が最も大きいため、この機能は多くの観光案内アプリが持つ特徴の1つであると考えられる。観光地図を実装したWebアプリを作成してそのパフォーマンスを計測することで、観光案内アプリにおけるService Workerのパフォーマンスを評価する。
\subsubsection{検証用のアプリの作成}\label{subsubsection:検証用のアプリの作成}
一般的にWebアプリはフレームワークを使用して作成される。そのため、検証用のアプリを作成する際も同種のソフトウェアを使用する。HTMLの生成方法は大きく分けて2種類あり、どちらを採用するかを決める必要がある。まずは、それらの方法を説明する。

最も基本的なHTMLの生成方法としては動的な生成がある。ユーザーがページにアクセスするたびにサーバー側でHTMLファイルが生成される。動的な生成を使用すると、ユーザーから任意のパラメーターを受け取り、それに基づいてHTMLを生成できる。後述する静的な生成では、Webアプリのプログラムを変更するたびにHTMLを生成し直さなければならないが、動的な生成ではその必要がないため、最新の情報を素早くユーザーに届けられる。動的な生成はSSR(Server Side Rendering)という仕組みによって実現しており、通常、HTMLを動的に生成する場合は、WebサーバーとWebアプリサーバーが必要である。

もう1つの生成方法は静的な生成である。Webアプリを変更してデプロイする際にはビルドという処理が行われるが、静的な生成では、この処理を行う際にそれぞれのページのHTMLファイルが生成される。したがって、ユーザーが特定のページにアクセスした際にクライアントに返却されるHTMLの内容は、ビルドが更新されない限り常に同じである。静的な生成はSSG(Static Site Generator)という仕組みによって実現しており、HTMLを静的に生成する場合はWebサーバーが必要である。

前述したように、静的な生成ではWebアプリのプログラムを変更するたびにHTMLを生成し直さなければならないという短所があり、コンテンツ指向型のWebアプリで静的なHTML生成が用いられることは少ない。そこで、検証用のアプリの作成時はHTMLを動的に生成する方法であるSSRを使用する。

次に観光地図を検証用のアプリに実装する。まずはOpenStreetMap~\cite{OpenStreetMap}を使用して地図レイヤーを表示する。OpenStreetMap(OSM)はコミュニティーによってメンテナンスされている、オープンソースの世界地図および地理データベースである。Overpass APIを使用して、観光名所に分類されるOSMのノードをJSONデータとして取得する。このノードをOSMの世界地図にプロットすることで、観光名所の場所がプロットされた地図を作成できる。Google Mapsに代表されるように、アプリに地図を表示する場合は、ズーム倍率を変更したり、自由にスクロールしたりできるインタラクティブ性が必要である。これを満たすためにLeaflet~\cite{Leaflet}を使用する。観光名所のマーカーにカーソルを合わせたり、そのマーカーをクリックした際に表示される画像やテキストを取得するために、JSONPlaceholderを使用する。JSONPlaceholderは、画像やテキストのダミーデータをREST APIで提供する。通常の観光地図には、特定の地域の観光名所のみがプロットされている。そのため、検証用のアプリでは国内の観光名所を都道府県ごとに表示する。
\subsubsection{Service Workerのキャッシュ戦略}\label{Service Workerのキャッシュパターン}
Service Workerのキャッシュパターンはキャッシュ戦略と呼ばれ、Service Workerを効果的に使用するために必要である。どのコンテンツをキャッシュするべきかはアプリの内容によって異なるため、キャッシュ戦略は無数にあるが、参考までにいくつか例を示す。

まずは、Service Workerのインストール時に全てのアセットをキャッシュする戦略がある。この戦略ではService Workerはアセットのキャッシュのみを返すため、HTMLなどのネットワークリクエストはService Workerを経由せず、キャッシュされない。

あるいは、全てのネットワークリクエストをService Workerに経由させる戦略もある。この戦略ではコンテンツは一切キャッシュされないが、常に最新のネットワークレスポンスを受け取れる。しかし、ユーザーがオフラインのときはWebアプリが機能しない。

このように、Service Workerはネットワークリクエストを仲介する役割を持つ。そのため、Service Workerを用いて一部のコンテンツのみをキャッシュすることもできる。キャッシュ対象のコンテンツの種類や範囲を変化させることでSerivce Workerのパフォーマンス評価を行うことにし、3種類のキャッシュ戦略を策定した。

1つ目はすべてのネットワークレスポンスをキャッシュする戦略である。この戦略では、HTML、CSS、JavaScript、画像、JSONなどのあらゆるネットワークレスポンスがService Workerによって全てキャッシュされる。同じページがもう1度読み込まれると、全てのネットワークレスポンスがキャッシュを利用するため、実質的にネットワークリクエストが発生しない。

2つ目はSame-Originのネットワークレスポンスをキャッシュする戦略である。この戦略ではWebアプリがデプロイされているドメイン(Same-Origin)に対するネットワークリクエストのみがキャッシュされる。同じページがもう1度読み込まれると、Same-OriginのネットワークレスポンスはCache Storageにあるキャッシュを利用し、Cross-Originのネットワークレスポンスはそのキャッシュを利用しない。

3つ目は画像をキャッシュする戦略である。観光案内アプリでは多くの画像が配信されるため、画像を積極的にキャッシュした際のパフォーマンスを知ることは、観光案内アプリでのPWAの有用性を評価する上で重要である。
\subsubsection{Service Workerのパフォーマンスの計測}\label{subsubsection:Service Workerのパフォーマンスの計測}
現在広く普及しているWebアプリの品質測定ツールとしてLighthouseがある。Lighthouseを使用すると、任意のページに対してパフォーマンス、ユーザー補助、PWA、SEOなどの監査を実施できる。今回はパフォーマンスに着目しているため、パフォーマンスの監査のみを実施する。より正確な指標を得るために、LighthouseのNodeモジュールを使用してモバイル端末での読み込みをエミュレートする。

Lighthouseのパフォーマンスの値は0から1で表され、監査項目の条件を満たしているほど、すなわちページの品質が高いほどその値が大きくなる。パフォーマンスの評価に役立つその他の指標としては以下のようなメトリクスがある。

\begin{itemize}
    \item First Contentful Paint(FCP)
    \begin{itemize}
        \item ページのナビゲーションが開始されてから、Webブラウザーがコンテンツの最初の部分をレンダリングするまでにかかる時間である。このコンテンツとはテキスト、画像、<svg>要素、白以外の<canvas>要素を指す。
    \end{itemize}
    \item Largest Contentful Paint(LCP)
    \begin{itemize}
        \item ページのナビゲーションが開始されてから、最も大きな画像またはテキストブロックをレンダリングするまでにかかる時間である。
    \end{itemize}
    \item Speed Index(SI)
    \begin{itemize}
        \item ページの読み込み中にコンテンツが視覚的に表示される速度である。ページを読み込む際に発生するフレーム間の視覚的な変化を計算し、SpeedlineというNodeモジュールを使用して点数を生成する。
    \end{itemize}
    \item Total Blocking Time(TBT)
    \begin{itemize}
        \item マクスのクリック、画面のタップ、キーボードの押下などのユーザー入力に対するページの応答がブロックされている合計時間である。
    \end{itemize}
    \item Cumulative Layput Shift(CLS)
    \begin{itemize}
        \item ページの読み込みの開始から終了までの間に発生したセッションウィンドウのうち、そのウィンドウ内のレイアウトシフトの累積値が最も大きいセッションウィンドウの測定値である。
    \end{itemize}
\end{itemize}

モバイル端末をエミュレートする際は、端末の幅、高さ、性能に加えてモバイル端末の通信環境もエミュレートする必要がある。しかし、4G以前のモバイル通信システムはIEEE 802.11acなどの広く普及している無線LANの標準規格に比べて通信速度が低いため、無線LANに接続した端末で、ネットワークエミュレーションを行わずにパフォーマンスを計測すると、実際のモバイル端末でのパフォーマンスを正確に計測できない可能性が高い。このような問題を回避するためにネットワークスロットリングを使用する。ネットワークスロットリングとはインターネットの速度を意図的に低下させ、低帯域の状態をエミュレートすることである。ネットワークスロットリングには以下の4種類がある。

\begin{itemize}
    \item シミュレートされたスロットリング
    \begin{itemize}
        \item スロットリングされていない最初の読み込みで観察されたデータに基づいてページの読み込みをシミュレートする。高速であるが一部のサイトではスロットリングの正確性が低い。
    \end{itemize}
    \item リクエストレベルのスロットリング
    \begin{itemize}
        \item ネットワークリクエストごとにスロットリングを行う。スロットリングの正確性はSimulated throttlingと同じ程度である。
    \end{itemize}
    \item プロキシーレベルのスロットリング
    \begin{itemize}
        \item HTTPサーバーを経由したTCPやUDPのネットワークリクエストごとにスロットリングを行う。
    \end{itemize}
    \item パケットレベルのスロットリング
    \begin{itemize}
        \item パケットごとにスロットリングを行う。このスロットリングを使用することで最も正確なネットワークシミュレーションを行える。
    \end{itemize}
\end{itemize}

この研究では、より正確なデータを得るために、パケットレベルのスロットリングを使用してパフォーマンスを計測する。